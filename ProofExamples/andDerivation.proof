begin proof derivationAnd 
    [ especificacion: and@xs = 〈∀ i : 0 ≤ i ∧ i < #xs : xs.i 〉] 
    induction in xs for 
        and@xs 
        .=. 
        case xs of [] -> True (y ▹ ys) -> y ∧ and@ys end 
    where
basic
[] -> and@[]
      ≡ { especificacion }
      〈∀ i : 0 ≤ i ∧ i < #[]: [].i 〉 
      ≡ { Longitud de la lista vacía }
      〈∀ i : 0 ≤ i ∧ i < 0: [].i 〉 
      ≡ { Harry Potter Equivalencia }
      〈∀ i : False : [].i〉 
      ≡ { especificacion }
      True
induction y ▹ ys with hypind -> and@(y ▹ ys)
                                ≡ { especificacion }
                                〈∀ i : 0 ≤ i < #(y ▹ ys) : (y ▹ ys).i〉
                                ≡ { Longitud de lista no vacía }
                                〈∀ i : 0 ≤ i ∧ i < 1+(#ys) : (y ▹ ys).i〉
                                ≡ { Harry Potter Equivalencia }
                                〈∀ i : 0 = i ∨ (0 < i ∧ i < 1+(#ys)) : (y ▹ ys).i〉
                                ≡ { especificacion }
                                〈∀ i : 0 = i : (y ▹ ys).i〉 ∧ 〈∀ i : 0 < i ∧ i < 1+(#ys) : (y ▹ ys).i〉
                                ≡ { especificacion }
                                (y ▹ ys).0 ∧ 〈∀ i : 0 < i ∧ i < 1+(#ys) : (y ▹ ys).i〉
                                ≡ { Proyectar el elemento inicial }
                                y ∧ 〈∀ i : 0 < i ∧ i < 1+(#ys) : (y ▹ ys).i〉
                                ≡ { Harry Potter Equivalencia }
                                y ∧ 〈∀ i : 0 < i ∧ i < #ys : (y ▹ ys).(i+1)〉
                                ≡ { Proyectar el elemento (i+1) }
                                y ∧ 〈∀ i : 0 < i ∧ i < #ys : ys.i〉
                                ≡ { especificacion }
                                y ∧ and@ys
end proof
